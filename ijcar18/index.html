<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Experiments with Encoding of Next State Relations of Imperative Programs</title>
    <meta name="author" content="Evgenii Kotelnikov"/>
    <link rel="stylesheet" type="text/css" href="../css/style.css"/>
    <script>
     (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
     m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
     ga('create', 'UA-52395119-1', 'auto');
     ga('send', 'pageview');
    </script>
  </head>
  <body>
    <header>
      <p><a href=".." class="back"><span>Back to Evgenii's webpage</span></a></p>
      <h1>Experiments with Encoding of the Next State Relations of Imperative Programs</h1>
      <p>Supplementary material for the paper &ldquo;A FOOLish Encoding of the Next State Relations of Imperative Programs&rdquo; by E.&nbsp;Kotelnikov, L.&nbsp;Kov&aacute;cs and A.&nbsp;Voronkov.</p>
      <p>If you have any questions please contact <a href="mailto:evgenyk@chalmers.se">Evgenii</a>.</p>
      <p><a href="./experiments.zip">Download all programs and benchmarks.</a></p>
    </header>
    <section>
      <h2>Programs with Loops</h2>
      <p><a href="./programs-with-loops.zip">10 Boogie programs with loops.</a></p>
    </section>
    <section>
      <h2>Loop-free Programs</h2>
      <p><a href="./loop-free-programs.zip">50 loop-free Boogie programs.</a></p>
    </section>
    <section>
      <h2>Benchmarks</h2>
      <ul>
        <li><a href="./boogie-benchmarks.zip">50 SMT-LIB problems</a> generated by <a href="https://www.microsoft.com/en-us/research/project/boogie-an-intermediate-verification-language/">Boogie</a></li>
        <li><a href="./voogie-benchmarks.zip">50 TPTP problems</a> generated by <a href="https://github.com/aztek/voogie">Voogie</a></li>
        <li><a href="./blt-benchmarks.zip">50 TPTP problems</a> generated by <a href="https://github.com/emptylambda/BLT">BLT</a></li>
      </ul>
    </section>
    <section>
      <h2>Experimental Results</h2>
      <p>The <a href="https://www.starexec.org/">StarExec</a> results obtained by running <a href="http://www.vprover.org/">Vampire</a> on <a href="./boogie-results.csv">the Boogie translations</a>, <a href="./voogie-results.csv">the Voogie translations</a>, and <a href="./blt-results.csv">the BLT translations</a>.</p>
    </section>
    <section>
      <h2>An Example of the Translation</h2>
      <h3>A Boogie program <code>maxarray</code> that finds the greatest element in an array</h3>
      <code><pre>// COST Verification Competition, Challenge 1: Maximum in an array
// http://foveoos2011.cost-ic0701.org/verification-competition

// Source: https://github.com/Microsoft/dafny/blob/master/Test/dafny2/COST-verif-comp-2011-1-MaxArray.dfy

var a: [int] int;
var n: int;

procedure main() returns (x: int)
  requires n > 0;
  ensures 0 <= x && x < n;
  ensures (forall i: int :: 0 <= i && i < n ==> a[i] <= a[x]);
{
  var y: int;
  /*ghost*/ var m: int;

  x := 0;
  y := n - 1;
  m := y;

  while (x != y)
    invariant 0 <= x && x <= y && y < n;
    invariant m == x || m == y;
    invariant (forall i: int :: 0 <= i && i < x ==> a[i] <= a[m]);
    invariant (forall i: int :: y <  i && i < n ==> a[i] <= a[m]);
  {
    if (a[x] <= a[y]) {
      x := x + 1;
      m := y;
    } else {
      y := y - 1;
      m := x;
    }
  }
}</pre></code>
      <h3>The Boogie program <code>maxarray</code> with its loop unrolled twice</h3>
      <code><pre>var a: [int] int;
var n: int;

var y: int;
/*ghost*/ var m: int;
var x: int;
var bad: bool;

procedure main()
  modifies x, y, m, bad;
  requires n > 0;
  requires 0 <= x && x <= y && y < n;
  requires m == x || m == y;
  requires (forall i: int :: 0 <= i && i < x ==> a[i] <= a[m]);
  requires (forall i: int :: y <  i && i < n ==> a[i] <= a[m]);

  ensures bad || (0 <= x && x <= y && y < n);
  ensures bad || (m == x || m == y);
  ensures bad || (forall i: int :: 0 <= i && i < x ==> a[i] <= a[m]);
  ensures bad || (forall i: int :: y <  i && i < n ==> a[i] <= a[m]);
{
  if (!(x != y)) {
    bad := true;
  }
  if (a[x] <= a[y]) {
    x := x + 1;
    m := y;
  } else {
    y := y - 1;
    m := x;
  }

  if (!(x != y)) {
    bad := true;
  }
  if (a[x] <= a[y]) {
    x := x + 1;
    m := y;
  } else {
    y := y - 1;
    m := x;
  }
}</pre></code>
      <h3>TPTP representation of the partial correctness property of <code>maxarray</code> obtained with Voogie</h3>
      <code><pre>tff(a, type, a : $array($int, $int)).
tff(bad, type, bad : $o).
tff(m, type, m : $int).
tff(n, type, n : $int).
tff(x, type, x : $int).
tff(y, type, y : $int).
tff(voogie_precondition_1, axiom,
    $greater(n, 0)).
tff(voogie_precondition_2, axiom,
    (($lesseq(0, x) &
       $lesseq(x, y)) &
       $less(y, n))).
tff(voogie_precondition_3, axiom,
    ((m = x) |
       (m = y))).
tff(voogie_precondition_4, axiom,
    (! [I : $int] : ((($lesseq(0, I) &
                        $less(I, x)) =>
                        $lesseq($select(a, I), $select(a, m)))))).
tff(voogie_precondition_5, axiom,
    (! [I : $int] : ((($less(y, I) &
                        $less(I, n)) =>
                        $lesseq($select(a, I), $select(a, m)))))).
tff(voogie_conjecture, conjecture,
    $let(bad : $o,
         bad := $ite(~(x != y),
                     $true,
                     bad),
    $let([m : $int, y : $int, x : $int],
         [m, y, x] := $ite($lesseq($select(a, x), $select(a, y)),
                           $let(x : $int,
                                x := $sum(x, 1),
                           $let(m : $int,
                                m := y,
                                [m, y, x])),
                           $let(y : $int,
                                y := $difference(y, 1),
                           $let(m : $int,
                                m := x,
                                [m, y, x]))),
    $let(bad : $o,
         bad := $ite(~(x != y),
                     $true,
                     bad),
    $let([m : $int, y : $int, x : $int],
         [m, y, x] := $ite($lesseq($select(a, x), $select(a, y)),
                           $let(x : $int,
                                x := $sum(x, 1),
                           $let(m : $int,
                                m := y,
                                [m, y, x])),
                           $let(y : $int,
                                y := $difference(y, 1),
                           $let(m : $int,
                                m := x,
                                [m, y, x]))),
         ((bad |
            (($lesseq(0, x) &
               $lesseq(x, y)) &
               $less(y, n))) &
            ((bad |
               ((m = x) |
                  (m = y))) &
               ((bad |
                  (! [I : $int] : ((($lesseq(0, I) &
                                      $less(I, x)) =>
                                      $lesseq($select(a, I), $select(a, m)))))) &
                  (bad |
                     (! [I : $int] : ((($less(y, I) &
                                         $less(I, n)) =>
                                         $lesseq($select(a, I), $select(a, m)))))))))))))).</pre></code>
    </section>
  </body>
</html>
